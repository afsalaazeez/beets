# ********RoostGPT********
"""
Test generated by RoostGPT for test beets using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=named_queries_0a3751ca24
ROOST_METHOD_SIG_HASH=named_queries_15a8118a09

```
Scenario 1: Test named_queries method with a model class that has corresponding queries in the plugins
Details:
  TestName: test_named_queries_with_existing_queries
  Description: This test aims to verify whether the named_queries method correctly identifies and gathers the queries from the plugins corresponding to the provided model class.
Execution:
  Arrange: Mock the find_plugins function to return a list of plugins, each with an attribute named 'model_cls_queries', where 'model_cls' is the name of the provided model class.
  Act: Invoke the named_queries function with the model class as a parameter.
  Assert: Check if the returned dictionary contains all the queries from the plugins for the provided model class.
Validation:
  This test verifies that the named_queries function correctly identifies and gathers all relevant queries from the plugins. This is crucial because the function's primary purpose is to collect these queries based on the provided model class.

Scenario 2: Test named_queries method with a model class that has no corresponding queries in the plugins
Details:
  TestName: test_named_queries_with_non_existing_queries
  Description: This test aims to verify whether the named_queries method correctly handles a scenario where the provided model class has no corresponding queries in the plugins.
Execution:
  Arrange: Mock the find_plugins function to return a list of plugins, none of which have an attribute named 'model_cls_queries', where 'model_cls' is the name of the provided model class.
  Act: Invoke the named_queries function with the model class as a parameter.
  Assert: Check if the returned dictionary is empty.
Validation:
  This test verifies that the named_queries function correctly handles a scenario where there are no corresponding queries in the plugins for the provided model class. This is important because it tests the function's ability to handle edge cases and return an empty dictionary when there are no relevant queries.

Scenario 3: Test named_queries method with a model class that has multiple corresponding queries in different plugins
Details:
  TestName: test_named_queries_with_multiple_queries
  Description: This test aims to verify whether the named_queries method correctly handles a scenario where the provided model class has multiple corresponding queries in different plugins.
Execution:
  Arrange: Mock the find_plugins function to return a list of plugins, more than one of which have an attribute named 'model_cls_queries', where 'model_cls' is the name of the provided model class.
  Act: Invoke the named_queries function with the model class as a parameter.
  Assert: Check if the returned dictionary contains all the queries from the plugins for the provided model class.
Validation:
  This test verifies that the named_queries function correctly handles a scenario where there are multiple corresponding queries in different plugins for the provided model class. This is important because it tests the function's ability to gather all relevant queries, even when they are spread across multiple plugins.
```
"""

# ********RoostGPT********
import pytest
from unittest.mock import MagicMock
from plugins import named_queries, find_plugins

class Test_PluginsNamedQueries:

    @pytest.mark.parametrize("model_cls, expected_result", [
        ('model1', {'query1': 'value1', 'query2': 'value2'}),
        ('model2', {'query3': 'value3', 'query4': 'value4'})
    ])
    def test_named_queries_with_existing_queries(self, model_cls, expected_result):
        plugins = [
            MagicMock(**{f'{model_cls}_queries': {'query1': 'value1', 'query2': 'value2'}}),
            MagicMock(**{f'{model_cls}_queries': {'query3': 'value3', 'query4': 'value4'}})
        ]
        find_plugins.return_value = plugins
        result = named_queries(model_cls)
        assert result == expected_result

    @pytest.mark.parametrize("model_cls", ['model1', 'model2'])
    def test_named_queries_with_non_existing_queries(self, model_cls):
        plugins = [
            MagicMock(**{f'{model_cls}_queries': {}})
        ]
        find_plugins.return_value = plugins
        result = named_queries(model_cls)
        assert result == {}

    @pytest.mark.parametrize("model_cls, expected_result", [
        ('model1', {'query1': 'value1', 'query2': 'value2', 'query3': 'value3', 'query4': 'value4'})
    ])
    def test_named_queries_with_multiple_queries(self, model_cls, expected_result):
        plugins = [
            MagicMock(**{f'{model_cls}_queries': {'query1': 'value1', 'query2': 'value2'}}),
            MagicMock(**{f'{model_cls}_queries': {'query3': 'value3', 'query4': 'value4'}})
        ]
        find_plugins.return_value = plugins
        result = named_queries(model_cls)
        assert result == expected_result
